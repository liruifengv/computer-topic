## 软件工程

### 软件开发有传统的三层结构方式， 即表示层、业务逻辑层、数据访问层三层，三层结构开发方式对比不采用三层机构软件开发的方式的优缺点？

传统的项目，广义上需要关注的是客户端和服务端；相当于是一个两层架构。

客户端：  包含界面、业务逻辑

服务端：  包含数据

这样的设计理念的最大的缺点是：

一旦服务端数据结构或数据名发生变化，客户端需要在很大范围内做改变，以适应新的数据。比如说服务端的一个数据名因故改变了，那么客户端代码中所有用到该条数据的地方都需要做改变。

三层架构的设计理念，把一个软件分为三个部分：

UI层：就是展现给客户的界面，用于展示用户输入以及服务端返回的数据；交互式操作界面中，用户输入的数据和想要的数据展示。

业务逻辑层： 桥梁层，用户输入的数据通过业务逻辑层的处理发给数据层；数据层返回的数据通过业务逻辑层发送给界面展示。常做的操作是验证、计算、业务规则等。

数据访问层：主要管理数据，实现对数据的增删改查等操作。把业务逻辑层提交的用户输入的数据保存，把业务逻辑层请求的数据返回给业务逻辑层。

三层架构的重要指导原则就是：高内聚、低耦合。

所以使用三层架构的最大目的就是：解耦。

#### 优点：
（1）避免了表示层直接访问数据访问层，表示层只和业务逻辑层有联系，提高了数据安全性。

（2）有利于系统的分散开发，每一个层可以由不同的人员来开发，只要遵循接口标准，利用相同的对象模型实体类就可以了，这样就可以大大提高系统的开发速度。

（3）方便系统的移植，如果要把一个 C/S 的系统变成 B/S 系统，只要修改三层架构的表示层就可以了，业务逻辑层和数据访问层几乎不用修改就可以轻松的把系统移植到网络上。

（4）项目结构更清楚，分工更明确，有利于后期的维护和升级。


#### 缺点

1）、分层也一样，如果不分层，很多业务可以直接访问数据库，获得数据，而现在却必须通过中间层来访问，从而降低了系统运行性能。

2）、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。

### 面向对象程序语言的三大特征分别是

1.封装，2.继承，3.多态
#### 封装
利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

优点：

- 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

#### 继承

当一个类继承了另一个类，通过关键字extends实现继承，被继承的叫父类，继承的类叫子类

#### 多态

简单的说就是父类型的引用指向子类型的对象。

多态分为编译时多态和运行时多态：

编译时多态主要指方法的重载
运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

### 设计模式
总体来说设计模式分为三大类：
- 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
- 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 面向对象的基本原则

- 单一责任原则

就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。


- 开放封闭原则

类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

- 里氏替换原则
子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

- 接口分离原则
不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

- 依赖倒置原则

>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

 - 任何变量都不应该持有一个指向具体类的指针或者引用；
 - 任何类都不应该从具体类派生；
 - 任何方法都不应该覆写它的任何基类中的已经实现的方法。

 